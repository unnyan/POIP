= Отчет №3
:toc:
:toc-title: Оглавление
:toclevels: 3

include::titul.adoc[]

== 1. Как работают прерывания и какие они бывают

Прерывание — это сигнал микроконтроллеру: «Стоп, тут срочно нужно сделать кое-что другое».

Они бывают трёх типов:

– Аппаратные (асинхронные)::  
  Приходят от внешних устройств — кнопок, датчиков, таймеров.

– Синхронные (исключения)::  
  Возникают внутри ядра — деление на ноль, неправильная инструкция.

– Программные::  
  Вызываются явно из кода специальной командой (например, `SVC`).

Аппаратные IRQ-линии делятся на:

* Маскируемые — их можно включать/выключать через контроллер прерываний NVIC.
* Немаскируемые (NMI) — всегда проходят, даже если другие отключены (например, при сбое питания).

Когда приходит прерывание, Cortex-M:

. Завершает текущую инструкцию и сохраняет часть регистров на стек.
. Проверяет в NVIC, разрешено ли это прерывание и какой у него приоритет.
. Берёт из таблицы векторов адрес функции-обработчика и прыгает туда.
. По окончании ISR восстанавливает контекст и продолжает выполнение основной программы.

== 2. Контроллер прерываний NVIC

NVIC (Nested Vectored Interrupt Controller) — это встроенный в Cortex-M диспетчер прерываний. Он:

* Управляет включением/отключением линий прерываний (IRQ).
* Назначает приоритеты — какие прерывания важнее.
* Позволяет одному прерыванию прервать другое (если у него выше приоритет).
* Сам запускает нужный обработчик (ISR), используя таблицу векторов.

== 3. Таблица векторов прерываний

Таблица векторов — это просто массив указателей на функции, который микроконтроллер читает при старте и при каждом прерывании.
Он находится в самом начале памяти (по адресу 0x00000000), и именно с него всё начинается.
Каждый элемент — это 4-байтный адрес (указатель) на обработчик или значение. Вот как выглядит начало:

. Элемент 0 — начальный адрес стека.
. Элемент 1 — адрес обработчика сброса (Reset).
. Элемент 2 — NMI (Non-Maskable Interrupt - это важные события, которые нельзя отключить — например, сбой питания или защита от внешнего вмешательства).
. Элемент 3 — HardFault (вызывается при фатальных ошибках: деление на 0, выход за границы памяти и т.д).
. Далее — другие исключения ядра, а затем внешние IRQ (например, TIM2, USART1).

Когда приходит IRQ №N, NVIC берёт адрес из ячейки `2 + N`.

== 4. Обработчик прерывания (ISR) и правила его написания

ISR — это функция, которая вызывается при возникновении прерывания. Чтобы всё работало корректно, нужно:

* Сразу сбросить флаг прерывания, иначе оно повторится.
* Не задерживать выполнение — никаких `delay()`, `printf()` и других "тяжёлых" операций.
* Минимизировать логику: просто выставить флаг или положить данные в буфер.
* Избегать вызова не-реентрантных функций (Не-реентрантная функция — это такая функция, которая не может быть безопасно вызвана повторно, если предыдущий вызов ещё не завершился. Например `printf()` `malloc()`).
* Основную обработку событий выносить в основной поток (например, в `main()`).

== 5. Пример: прерывание по переполнению таймера TIM2

=== 5.1 Настройка таймера

[source,c]
----
htim2.Init.Prescaler = 8400 - 1;    // делим 84 МГц на 8400 → 10 кГц
htim2.Init.Period    = 10000 - 1;   // считаем до 10000 → 1 секунда
HAL_TIM_Base_Init(&htim2);
HAL_TIM_Base_Start_IT(&htim2);      // запускаем с прерываниями
----

=== 5.2 Включение IRQ в NVIC

[source,c]
----
HAL_NVIC_SetPriority(TIM2_IRQn, 1, 0);
HAL_NVIC_EnableIRQ(TIM2_IRQn);
----

=== 5.3 Обработчик и колбек

[source,c]
----
void TIM2_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim2);  // сброс флага и вызов колбека
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) {
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);  // мигаем светодиодом
    }
}
----

=== 5.4 Механизм работы

1. Таймер считает до значения `Period`.
2. Устанавливается флаг переполнения (UIF).
3. NVIC вызывает `TIM2_IRQHandler`.
4. HAL сбрасывает флаг и вызывает колбек.
5. В колбеке мигает светодиод.
6. По завершении ISR Cortex-M продолжает выполнение основной программы.

== Выводы

* Прерывания позволяют микроконтроллеру **мгновенно реагировать** на внешние и внутренние события.
* NVIC управляет приоритетами и запуском соответствующих обработчиков.
* ISR (обработчики) должен быть **быстрым и минимальным**, без тяжёлых операций.
* Таблица векторов — это карта, по которой NVIC находит нужную функцию.
* Работа с таймерами и прерываниями — базовый и очень важный навык в embedded-разработке.
