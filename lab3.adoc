= Отчет №3
:toc:
:toc-title: Оглавление
:toclevels: 3

include::titul.adoc[]

== 1. Как работают прерывания и какие они бывают

Прерывание — это сигнал микроконтроллеру: «Стоп, тут срочно нужно сделать кое-что другое».

Они бывают трёх типов:

– Асинхронные::  
  Приходят от внешних устройств — кнопок, датчиков, таймеров.

– Синхронные (исключения)::  
  Возникают внутри ядра — деление на ноль, неправильная инструкция.

– Программные::  
  Вызываются явно из кода специальной командой (например, `SVC`).

Аппаратные IRQ-линии делятся на:

* Маскируемые — их можно включать/выключать через контроллер прерываний NVIC.
* Немаскируемые (NMI) — всегда проходят, даже если другие отключены (например, при сбое питания).

Когда приходит прерывание, Cortex-M:

. Завершает текущую инструкцию и сохраняет часть регистров на стек.
. Проверяет в NVIC, разрешено ли это прерывание и какой у него приоритет.
. Берёт из таблицы векторов адрес функции-обработчика и прыгает туда.
. По окончании ISR восстанавливает контекст и продолжает выполнение основной программы.

== 2. Контроллер прерываний NVIC

NVIC (Nested Vectored Interrupt Controller) — это встроенный в Cortex-M диспетчер прерываний. Он:

* Управляет включением/отключением линий прерываний (IRQ).
* Назначает приоритеты — какие прерывания важнее.
* Позволяет одному прерыванию прервать другое (если у него выше приоритет).
* Сам запускает нужный обработчик (ISR), используя таблицу векторов.

== 3. Таблица векторов прерываний

Таблица векторов — это просто массив указателей на функции, который микроконтроллер читает при старте и при каждом прерывании.
Он находится в самом начале памяти (по адресу 0x08000000), и именно с него всё начинается.
Каждый элемент — это 4-байтный адрес (указатель) на обработчик или значение. Вот как выглядит начало:

. Элемент 0 — начальный адрес стека.
. Элемент 1 — адрес обработчика сброса (Reset).
. Элемент 2 — NMI (Non-Maskable Interrupt - это важные события, которые нельзя отключить — например, сбой питания или защита от внешнего вмешательства).
. Элемент 3 — HardFault (вызывается при фатальных ошибках: деление на 0, выход за границы памяти и т.д).
. Далее — другие исключения ядра, а затем внешние IRQ (например, TIM2, USART1).


== 4. Обработчик прерывания (ISR) и правила его написания

ISR — это функция, которая вызывается при возникновении прерывания. Чтобы всё работало корректно, нужно:

* Сразу сбросить флаг прерывания, иначе оно повторится.
* Не задерживать выполнение — никаких `delay()`, `printf()` и других "тяжёлых" операций.
* Минимизировать логику: просто выставить флаг или положить данные в буфер.
* Избегать вызова не-реентрантных функций (Не-реентрантная функция — это такая функция, которая не может быть безопасно вызвана повторно, если предыдущий вызов ещё не завершился. Например `printf()` `malloc()`).
* Основную обработку событий выносить в отдельную задачу.

== 5. Пример: прерывание по переполнению таймера TIM2

[source,c]
----
class TimerHandler
{
public:
  inline static volatile bool IsDelayComplete = false;

  static void Tim2Handler()
  {
    if (TIM2::SR::UIF::InterruptPending::IsSet() and TIM2::DIER::UIE::Enable::IsSet())
    {
      TIM2::SR::UIF::NoInterruptPending::Set(); // сброс флага прерывания
      IsDelayComplete = true;                   // флаг завершения задержки
    }
  }
};

----

Что происходит в этом коде:

- Метод Tim2Handler() — это обработчик прерывания для TIM2.
- Он проверяет, что: установлен флаг UIF (Update Interrupt Flag) — переполнение произошло, и что разрешены прерывания по этому событию (UIE).
- Если оба условия выполняются: флаг UIF сбрасывается, переменная IsDelayComplete устанавливается в true — сигнал, что таймер отработал.

== Выводы

* Прерывания позволяют микроконтроллеру **мгновенно реагировать** на внешние и внутренние события.
* NVIC управляет приоритетами и запуском соответствующих обработчиков.
* ISR (обработчики) должен быть **быстрым и минимальным**, без тяжёлых операций.
* Таблица векторов — это карта, по которой NVIC находит нужную функцию.
* Работа с таймерами и прерываниями — базовый и очень важный навык в embedded-разработке.
