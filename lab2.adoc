= Отчет №2
:toc:
:toc-title: Оглавление
:toclevels: 3
:sectnums:

include::titul.adoc[]

== Типы данных, преобразования и указатели

=== Типы данных

В языке C есть базовые типы:
`char` — 1 байт (символ),
`int` — обычно 4 байта,
`float` — дробные числа (обычно 4 байта),
`double` — более точные дробные числа (обычно 8 байт),
`void` — специальный тип, означает «ничего».

Также есть модификаторы: `short`, `long`, `signed`, `unsigned`.

Кроме того, в языке C существуют структурные (например `struct` — позволяет объединять переменные разных типов в одну структуру) и адресные (указатели `*` — специальные переменные, хранящие адреса других переменных.
Например: `int *ptr;` — указатель на `int`) типы. С их помощью можно работать с динамической памятью, передавать параметры по ссылке и строить сложные структуры данных.

=== Размер типов и `sizeof`

Размер переменной можно узнать с помощью `sizeof(тип)` или `sizeof(переменная)`. Например:  
`sizeof(int)` обычно равен 4 байта.

==== Формула для вычисления общего размера структуры:

Если структура состоит из нескольких полей, общий размер можно приближённо выразить так:

[source,cpp]
----
sizeof(struct) ≈ sizeof(поле1) + sizeof(поле2) + ... + выравнивание
----

Пример:

[source,cpp]
----
struct Example {
    char a;   // 1 байт
    int b;    // 4 байта
};
----

Фактический размер такой структуры может быть 8 байт, а не 5, из-за выравнивания памяти (например, `int` должен начинаться с адреса, кратного 4).

=== Преобразование типов

==== Неявное преобразование

Неявное преобразование (implicit conversion) происходит автоматически, когда компилятор сам приводит один тип к другому, чтобы выполнить операцию.

Например:

[source,cpp]
----
int a = 5;
double b = 3.2;
double result = a + b; // int автоматически преобразуется в double
----

==== Явное преобразование

Явное преобразование (explicit conversion) выполняется программистом вручную. В языке C используется так называемое "приведение типа":

[source,cpp]
----
double x = 3.14;
int y = (int)x; // y станет равным 3, дробная часть отбрасывается
----

В C++ для более строгого и понятного управления типами используются специальные операторы приведения:

===== static_cast

`static_cast<T>(value)` используется для *безопасных и логичных преобразований* между совместимыми типами.

[source,cpp]
----
double pi = 3.14;
int n = static_cast<int>(pi); // преобразование double → int
----

Также применяется для:

- преобразования между числовыми типами (int, float и т.д.),
- приведения указателей внутри иерархии классов,
- удаления модификаторов типа (`const`, `volatile`) — с осторожностью.

===== reinterpret_cast

`reinterpret_cast<T>(value)` используется для *низкоуровневого преобразования между несовместимыми типами*, чаще всего с указателями.

[source,cpp]
----
int a = 42;
char* p = reinterpret_cast<char*>(&a); // интерпретирует адрес int как указатель на char
----

[NOTE]
====
Такое преобразование может привести к неопределённому поведению и должно использоваться только при точном понимании последствий.
====

Преобразования, особенно из `float` или `double` в `int`, могут привести к *потере точности*, так как дробная часть просто отбрасывается.


=== Указатели

Указатель — это переменная, которая хранит адрес другой переменной:

[source,cpp]
----
int a = 5;
int* ptr = &a;
----

Можно использовать `*` (разыменование), `&` (взятие адреса), `+`/`-` (арифметика указателей), `==`/`!=`.

Важно: нельзя вычитать указатели, указывающие на разные объекты — это неопределённое поведение.

=== Работа с битами

* Установить бит: `x |= (1 << n);`
* Сбросить бит: `x &= ~(1 << n);`
* Инвертировать бит: `x ^= (1 << n);`

== Унарные операторы `+` и `-`

Унарные операторы применяются к одному операнду и выполняют простые арифметические действия.

* `-` — меняет знак переменной:

[source,cpp]
----
int x = 5;
int y = -x; // y = -5
----

* `+` — **не изменяет значение**, но выполняет *integer promotion* (целочисленное расширение).

В большинстве случаев унарный `+` используется редко, но **при применении к значениям меньших типов** (например, `char` или `short`) он приводит их к `int` согласно правилам *integer promotion*.

[source,cpp]
----
char c = 100;
int result = +c; // c продвигается до int перед операцией
----

Это особенно важно, если операции с типами меньшей разрядности могут вызвать переполнение или изменить поведение программы.

[NOTE]
====
Integer promotion — это автоматическое преобразование значений типов `char`, `short` (и других «меньших» целочисленных типов) в тип `int` или `unsigned int` перед выполнением большинства операций. Это правило встроено в спецификацию языка C/C++.
====


== Почему `17 000 000 + 1 == 17 000 000` в `float`

Тип `float` имеет ограниченную точность — около 7 значащих цифр.  
Если число слишком большое, прибавление "1" не изменяет результат, потому что дробная часть оказывается меньше единицы последнего разряда в мантиссе и теряется.

== Почему `7 != 7` в коде на `float`

При делении `7.7f / 1.1f` результат не будет ровно `7`, из-за ограниченной точности `float`. Он получится чуть меньше (`6.999999...`), и сравнение с `7.0f` не сработает.

[source,cpp]
----
#include <iostream>
#include <iomanip>

float GetMagicSeven(float num) {
    return 7.7f / 1.1f;
}

int main() {
    const float Seven = 7.0f;
    float magicSeven = GetMagicSeven(Seven);

    std::cout << std::fixed << std::setprecision(10);

    if (magicSeven == Seven) {
        std::cout << "7f == 7f" << std::endl;
    } else {
        std::cout << "7f != 7f" << std::endl;
        std::cout << "magicSeven: " << magicSeven << std::endl;
        std::cout << "Seven: " << Seven << std::endl;
    }

    return 0;
}
----

=== Пример вывода:

----
7f != 7f  
magicSeven: 6.9999995232  
Seven: 7.0000000000  
----

== Работа с GPIO

На занятии мы научились вручную управлять регистрами ввода-вывода, без использования готовых библиотек.

[source,cpp]
----
volatile std::uint32_t* const ptrGpioaOdr =
  reinterpret_cast<volatile std::uint32_t*>(0x40020014);

*ptrGpioaOdr |= (1U << 5U);  // Включаем светодиод на PA5
----

=== Полный пример работы со светодиодами

[source,cpp]
----
for(;;)
{
    volatile std::uint32_t* const ptrGpioaOdr =
      reinterpret_cast<volatile std::uint32_t*>(0x40020014);
    volatile std::uint32_t* const ptrGpiocOdr =
      reinterpret_cast<volatile std::uint32_t*>(0x40020814);

    delay(1000000);

    *ptrGpioaOdr |= (1U << 5U);
    *ptrGpiocOdr |= (1U << 9U);
    *ptrGpiocOdr |= (1U << 8U);
    *ptrGpiocOdr |= (1U << 5U);

    delay(1000000);

    *ptrGpioaOdr &= ~(1U << 5U);
    *ptrGpiocOdr &= ~(1U << 9U);
    *ptrGpiocOdr &= ~(1U << 8U);
    *ptrGpiocOdr &= ~(1U << 5U);
}
----

== Выводы

* Преобразования типов бывают неявные и явные — и могут вести к потере точности.
* `float` не всегда хранит точные значения, особенно при больших числах или делении.
* Побитовые операции дают гибкий способ работы с отдельными битами.
* С указателями нужно быть осторожным — важно понимать, что ты делаешь в памяти.
* Управление GPIO напрямую дало лучшее понимание взаимодействия с железом на уровне регистров.
