= Отчет №2
:toc:
:toc-title: Оглавление
:toclevels: 3

include::titul.adoc[]

== 1. Типы данных, преобразования и указатели

=== 1.1 Типы данных

В языке C есть базовые типы:
`char` — 1 байт (символ),
`int` — обычно 4 байта,
`float` — дробные числа (обычно 4 байта),
`double` — более точные дробные числа (обычно 8 байт),
`void` — специальный тип, означает «ничего».

Также есть модификаторы: `short`, `long`, `signed`, `unsigned`.

=== 1.2 Размер типов и `sizeof`

Размер переменной можно узнать с помощью `sizeof(тип)` или `sizeof(переменная)`. Например:  
`sizeof(int)` обычно равен 4 байта.

=== 1.3 Преобразование типов

==== 1.3.1 Неявное преобразование

Когда компилятор сам меняет тип данных (например, `int + double → double`).

==== 1.3.2 Явное преобразование

Когда мы явно указываем, какой тип должен быть:

[source,cpp]
----
double x = 3.14;
int y = (int)x; // явное преобразование
----

Также в C++ можно использовать:
* `static_cast` — безопасное и логичное преобразование
* `reinterpret_cast` — грубое, низкоуровневое преобразование (например, указателей)

Преобразования могут привести к потере точности, особенно при переводе из `float` или `double` в `int`.

=== 1.4 Указатели

Указатель — это переменная, которая хранит адрес другой переменной:

[source,cpp]
----
int a = 5;
int* ptr = &a;
----

Можно использовать `*` (разыменование), `&` (взятие адреса), `+`/`-` (арифметика указателей), `==`/`!=`.

Важно: нельзя вычитать указатели, указывающие на разные объекты — это неопределённое поведение.

=== 1.5 Работа с битами

* Установить бит: `x |= (1 << n);`
* Сбросить бит: `x &= ~(1 << n);`
* Инвертировать бит: `x ^= (1 << n);`

== 2. Унарные операторы `+` и `-`

* `+` ничего не меняет, просто показывает знак.
* `-` меняет знак переменной:

[source,cpp]
----
int x = 5;
int y = -x; // y = -5
----

== 3. Почему `17 000 000 + 1 == 17 000 000` в `float`

Тип `float` имеет ограниченную точность — около 7 значащих цифр.  
Если число слишком большое, прибавление "1" не изменяет результат, потому что дробная часть оказывается меньше единицы последнего разряда в мантиссе и теряется.

== 4. Почему `7 != 7` в коде на `float`

При делении `7.7f / 1.1f` результат не будет ровно `7`, из-за ограниченной точности `float`. Он получится чуть меньше (`6.999999...`), и сравнение с `7.0f` не сработает.

[source,cpp]
----
#include <iostream>
#include <iomanip>

float GetMagicSeven(float num) {
    return 7.7f / 1.1f;
}

int main() {
    const float Seven = 7.0f;
    float magicSeven = GetMagicSeven(Seven);

    std::cout << std::fixed << std::setprecision(10);

    if (magicSeven == Seven) {
        std::cout << "7f == 7f" << std::endl;
    } else {
        std::cout << "7f != 7f" << std::endl;
        std::cout << "magicSeven: " << magicSeven << std::endl;
        std::cout << "Seven: " << Seven << std::endl;
    }

    return 0;
}
----

=== Пример вывода:

----
7f != 7f  
magicSeven: 6.9999995232  
Seven: 7.0000000000  
----

== 5. Работа с GPIO

На занятии мы научились вручную управлять регистрами ввода-вывода, без использования готовых библиотек.

[source,cpp]
----
volatile std::uint32_t* const ptrGpioaOdr =
  reinterpret_cast<volatile std::uint32_t*>(0x40020014);

*ptrGpioaOdr |= (1U << 5U);  // Включаем светодиод на PA5
----

=== 5.1 Полный пример работы со светодиодами

[source,cpp]
----
for(;;)
{
    volatile std::uint32_t* const ptrGpioaOdr =
      reinterpret_cast<volatile std::uint32_t*>(0x40020014);
    volatile std::uint32_t* const ptrGpiocOdr =
      reinterpret_cast<volatile std::uint32_t*>(0x40020814);

    delay(1000000);

    *ptrGpioaOdr |= (1U << 5U);
    *ptrGpiocOdr |= (1U << 9U);
    *ptrGpiocOdr |= (1U << 8U);
    *ptrGpiocOdr |= (1U << 5U);

    delay(1000000);

    *ptrGpioaOdr &= ~(1U << 5U);
    *ptrGpiocOdr &= ~(1U << 9U);
    *ptrGpiocOdr &= ~(1U << 8U);
    *ptrGpiocOdr &= ~(1U << 5U);
}
----

== Выводы

* Преобразования типов бывают неявные и явные — и могут вести к потере точности.
* `float` не всегда хранит точные значения, особенно при больших числах или делении.
* Побитовые операции дают гибкий способ работы с отдельными битами.
* С указателями нужно быть осторожным — важно понимать, что ты делаешь в памяти.
* Управление GPIO напрямую дало лучшее понимание взаимодействия с железом на уровне регистров.
