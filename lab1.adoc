= Отчет №1
:toc:
:toc-title: Оглавление
:toclevels: 3
:sectnums:

include::titul.adoc[]

== Этапы разработки и кто пишет код

Разработка программ для микроконтроллеров проходит в несколько этапов: сначала нужно понять, что должна делать программа, потом продумать, как это лучше реализовать, затем уже пишется код, проводится отладка и тестирование.  
Как я поняла, написание самого кода — это только часть работы. Часто ей занимаются менее опытные инженеры или стажёры, потому что более квалифицированные специалисты обычно занимаются архитектурой, планированием и проверкой кода. Это позволяет распределять задачи эффективно: кому-то проектировать, кому-то реализовывать.


== Как происходит компиляция и создаётся прошивка

Компиляция — это процесс, в котором наш текстовый код переводится в набор машинных команд, понятных микроконтроллеру. В IAR Workbench это всё делается автоматически при сборке проекта.  
Программа проходит несколько этапов: сначала обрабатываются заголовки и макросы, потом компилятор переводит код в промежуточный формат, затем всё собирается в один исполняемый файл. После этого создаётся прошивка в формате `.hex` или `.bin`, которую можно загрузить в микроконтроллер. Всё это происходит довольно быстро, но включает в себя много внутренних шагов, которые мы пока просто принимаем как "магия компиляции".

=== Таблица: Этапы компиляции в IAR Workbench

[cols="1,3", options="header"]
|===
| Этап
| Что происходит в IAR Workbench

| Препроцессинг
| Обрабатываются директивы `#include`, макросы и условная компиляция. Всё это делается автоматически внутри среды при сборке проекта.

| Компиляция
| Исходный код переводится в ассемблерные инструкции. При этом применяются оптимизации, проверяются синтаксис и типы данных.

| Ассемблирование
| Ассемблерный код преобразуется в объектные файлы `.o`, содержащие машинные команды без адресов.

| Линковка
| Все объектные файлы и библиотеки объединяются в один исполняемый образ.
|===



== Что происходит до вызова функции `main()`

Хотя нам кажется, что всё начинается с `main()`, на самом деле микроконтроллер сначала выполняет другие важные действия: он сбрасывает все настройки, инициализирует память, настраивает тактирование и только потом запускает `main()`.  
Это всё происходит благодаря специальным стартовым файлам, которые входят в проект — мы их напрямую не трогаем, но без них программа бы не заработала. В IAR это всё уже настроено, так что нам достаточно просто писать `main()` и не переживать о низкоуровневых деталях.


== Почему результат выражения равен 12
[source,cpp]
----
#include <iostream>


int Increment(int value)
{
    static int result = value;
    result ++;
    return result;
}


int main()
{
    auto result = Increment(10);
    std::cout << "result == " << result << std::endl; // 11

    result = Increment(12);
    std::cout << "result == " << result << std::endl; //12
}
----
Ключевое слово static означает, что переменная result создаётся один раз при первом вызове функции и сохраняет своё значение между вызовами.  
При следующих вызовах инициализация = value не выполняется повторно.

Пошагово:

* Первый вызов: Increment(10)
** result создаётся и инициализируется: result = 10
** затем result++ → становится 11
** возвращается 11

* Второй вызов: Increment(12)
** строка static int result = value; не срабатывает, так как result уже создан
** текущее значение result — 11 (осталось с прошлого вызова)
** затем result++ → становится 12
** возвращается 12

== Выводы

В ходе разбора вопросов я лучше поняла, как устроен процесс разработки программ под микроконтроллеры, особенно в среде IAR Workbench.  
Стало понятно, что:

* Написание кода — только часть общей работы, и часто выполняется менее опытными разработчиками.
* Компиляция — это целый процесс из нескольких этапов, а не просто одна кнопка "Build".
* До запуска `main()` микроконтроллер проходит важные шаги инициализации.
* В примере показано, как `static` переменная внутри функции сохраняет значение между вызовами. Инициализация происходит только один раз, поэтому поведение функции не зависит от новых аргументов.

Эти знания помогают глубже понять, что именно происходит в проекте, и на что стоит обращать внимание при работе с микроконтроллерами.
